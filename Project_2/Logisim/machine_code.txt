//NOT TESTED! CAN CONTAIN BUGS!
.data
	sum:	0
	pin_1:	0xFFF0
	pin_2:	0xFFF2
	pb_1:	0xFFF1
	pb_2:	0xFFF3
	7_seg:	0xFFF4
	one:	1
	zero:	0
	two:	2
.code

start	ldi 6 sum
	ldi 0 pb_1 // from here
	ld 0 0
	ldi 1 one
	xor 2 0 1
	jz pb_1pressed
	ldi 0 pb_2
	ld 0 0
	xor 2 0 1
	jz pb_2pressed
	jmp start // to here is  newest structure


pb_1pressed ldi 4 pin_1 // load pin_1's value to reg_4
	ld 4 4
	ldi 5 two
	ld 5 5
	call mult
	add 6 6 3
	ld 6 0
	call display

pb_2pressed ldi 4 pin_2 // load pin_2's value to reg_4
	ld 4 4
	ld 5 6
	call mult
	ld 0 6
	call display



lessthan //if r5 <= r4 reg_6 = 0 else 1 
		ret

//Multiplication function
//This function is reg_6 = reg_5 * reg_4
mult	ldi 6 zero //Load zero to reg_6
	ldi 6 6
mult_loop	add 6 6 4 //Add reg_4 to reg_6 our objective in here is the add reg_4 to reg_6 reg_5 times.
	dec 5 //Decrease reg_5
	jz mult_end //if reg_5 is zero end the multiplication
	jmp mult_loop  //if not continiue
mult_end	ret//return to address

// A function for division works as reg_6 = reg_4 / reg_5
div	call lessthan // Check if reg_4 is bigger than reg_5 in order to begin the division
	jz div_end
	ldi 6 zero //Assign zero to reg_6
	ld 6 6
div_loop	inc 6 //increment the result
	sub 4 4 5 //substract reg_5 from reg_4
	call lessthan //check if reg_5 is still bigger than reg_4
	jz div_end //if not end the division
	jmp div_loop //if continue to division
div_end	ret //return to address
	

display //convert 1th register to display
	call hextobcd
	ldi 1 seven_seg
	st 6 1
	ret

//This function takes reg_0 and 
hextobcd
	ldi 2 zero
	ld 2 2
	ld 4 0
	ldi 5 0x3E8 // 1000
	ld 5 5
	call div
	push 6
	ldi 5 0x64 // 100
	ld 5 5
	call div
	push 6
	ldi 5 0xA // 10
	ld 5 5
	call div
	push 6
	ldi 5 0x1 // 1
	ld 5 5
	call div
	push 6
//	
	ldi 1 zero
	ld 1 1
	ldi 5 0x1
	ld 5 5
	pop 4
	call mult
	add 1 1 6
	ldi 5 0x10
	ld 5 5
	pop 4
	call mult
	add 1 1 6
	ldi 5 0x100
	ld 5 5
	pop 4
	call mult
	add 1 1 6
	ldi 5 0x1000
	ld 5 5
	pop 4
	call mult
	add 1 1 6
	ret
//